---
title: AI, Vibe Coding & The Joy of Building
---

It's 2026, and we are just seeing the top-level effects of AI unfold. It is barely a year since [Claude Code](https://claude.ai/code), [Amp](https://ampcode.com), and others were launched, and boy, how these tools have shaped the way I did my job over the past year.

I have been experimenting with vibe coding since around September 2024 (if you were to include the tab auto-complete which came out with GitHub Copilot, then I don't remember the year, but since then). I started out with Cursor like most folks (I guess?), and again like most, I didn't like what it was doing. It made me slower rather than giving me a performance bump, resulting in me dumping it altogether.

I went back to it a couple more times on and off and didn't like it until Jan/Feb 2025. One weekend, I was just sitting idle, getting bored, and thought to myself, "Let's build a side project we have been putting off for a long time." I opened up Cursor in an attempt to try and use the tool properly this time, since I actually had some time on my hands rather than the previous couple of times where I just wanted it to help me ship something faster without thinking much about what a tool like this would look like.

I started out with an attempt that I'll program most of it. I would read a lot since I hadn't had a lot of experience in building the tool I was building, and I would use Cursor to learn better and help automate smaller things like bootstrapping the project, etc.

To my surprise, the project had improved quite a lot (and also my intuition on how to use it as well, thanks to Twitter). It gave me good results in the small directional prompts that I gave it without needing much hand-holding. I think a lot of this is attributable to the model improving as well, since the models were also improving rather exponentially at that time. As a result, I was able to get a very crude (made for learning purposes) version of [Veil](https://github.com/try-veil/veil) up and running and even set up a proper homebrew installation for it—something I had never done before, nor did I have to think about it much.

This was my first encounter with understanding the power of these AI-assisted coding tools for the first time, and I was absolutely in awe. I felt the sort of joy that I had felt the first time I created a QBasic program back in 6th grade—the feeling of magic, the feeling of sensing the vast potential it gave me. The same raw joy overpowered me, and ever since then, I kept coming back to it.

The codebase at work and the tools were not mature enough to leverage it at work yet, but even then, I kept coming back to it for Veil and for trying to leverage it to build some other things. As a normal course of progression, I tried to get it to do more and more. As a result, it started sucking again, since it was not very good at handling long-running tasks at that time (and also felt like a token sink to me).

This went on for the next 4-5 months. During this time, [Amp](https://ampcode.com) came out, and they very generously gave us some free credits. There was a lot of hype around it, and I am always keen to try it out, so I gave it a spin. Boy, oh boy, did it impress me. It helped me set up a 7-year-old legacy Python monolith in mere minutes and debugged the issue I was working on completely. However, this tool was too expensive for me to sustain, and hence I went back to Cursor and VS Code Copilot.

Then I laid my hands on Claude Code, and boy, I was blown away. This tool pushed me out of the IDE in such a natural way. It was able to understand what I was trying to tell it—a legit feeling of someone who _just gets it_. It was like finding that one co-worker you can just talk to in one sentence, and they just understand the entire context of how you are trying to engineer something.

It helped me ship so much at work, all the while rarely opening up an IDE. Sure, there were casual sessions where it messed things up, and I had to spend time debugging what it was doing and ask it to make smaller edits. But those instances also made me realize that at the end of the day, it's not a real human but a tool, and I should steer it correctly. It's much like a car which can get me from home to work much faster than running or walking, but needs me to keep steering it in the right direction at the right time, else it would just cause a massive accident. It was sort of the same realization, and I focused on improving my workflows, planning, and the way I steered and orchestrated the tasks. In some ways, it helped me think more in terms of a manager—the same analogies of how I would get a fresh-out-of-college average intern to help me out in my day-to-day. I tried applying the same principle to working with Claude, and it has served me well.

This entire journey of the better part of 2025 has helped me understand the exact difference between "vibe coding" something and actually doing AI-assisted development. The latter is for serious work for an actual engineer at work, and the former is for someone just trying to have fun, trying to hack together a simple dashboard, or a script to assist you with things that are trivial and low-reward for the effort of actually sitting and coding out by your own hands. But if someone were to spit those out reliably in mere minutes, they add a lot of value in speeding up your workflow. A simple dashboard which sanitises the `task_ids` to be used between different tools like your Axiom log stream and the Datadog trace, or building a visualiser for rendering a transcript in a particular visual format for easy viewing, or just simply stringing together a small web page for showcasing the results and summary of the week-long sprint to the CTO of your company.

All the above are small, low-blast-radius, good-to-have use-cases where neither the quality of code matters nor the structure because these are use-and-throw. An example of this is this [tweet](https://x.com/mitchellh/status/2010112766871515262?s=20) by Mitchell (the creator of [Ghostty](https://ghostty.org)).

AI-assisted development, on the other hand, is using AI to save on time and bridge the gap between your knowledge, understanding, and execution. It means taking ownership of the code; the AI can generate it, implement your ideas for you, but it might not make the same decisions as you did. As a programmer, you need to be able to foresee what it is going to do wrong or might do wrong. You might not be able to do that completely, obviously, but as you learn with your own experience, you understand those patterns and you need to account for them.

AI-assisted development means reading through the code it has generated because it's your code at the end of it all. Even if you get your tool to commit code, it says that it was `Co-Authored` by it (`Co` being the keyword here). AI cannot and should not be held responsible for the output or the bugs that might come with the unverified and unreviewed code the AI generated. That onus still, and for a foreseeable future, will remain on the engineer working with it. This is a singular understanding which also makes me feel that my job just got better and expanded its scope rather than being on the verge of going extinct or being taken away by a machine/tool. Sure, if you don't have the love of the craft, don't have attention to detail or taste, and you just focused on pushing Jiras on a board, you are right to be concerned. Someone who has a much higher bar for the worth of their time will not settle for your mediocrity anymore and would just get an agent to do those things because you were nothing more than that—just an older version of the agent like Cursor was with me back in 2024 when I couldn't get it to do things. The only difference being before the advent of LLMs, these human agents were required for these high-agency, love-of-the-game programmers/engineers/builders to delegate the offbeat grunt tasks. But with AI, that constraint has been partially removed and will keep getting smaller and smaller as people come to understand that the output which AI generates is nothing but a reflection of what you would have generated yourself given enough time to generate it. What the tool did is just compress and condense the timeline of getting that output out and showing it's results, if you care about what you are shipping, quality of your work,  you will always ensure that no-matter who did the implementation it meets the exact standards of quality that you have in your mental model. Infact these tools help you ensure those standards are met and tracked rather easily because the manual labour of setting up those guardrails and feedback loops and most of all maintaining them, could easily be delegated off to the AI agent.

For me personally, the builder in me has never been happier, and also this experience has been a grounding one. It has made me see my strengths and also my weaknesses—where I lack, where I need help, and where my execution is flawless. One such area is not sticking to things long enough to finish them properly. I have started a couple of projects with LLMs and agents and that has helped me learn a lot technically, but it has also made me realize that I haven't finished and shared anything completely and properly with the world. That balance between perfectionism and being clean & usable enough to ship and iterate on things is missing, but now that it has been identified, I am working towards closing the gap real fast.

This is such a great time to be working in this industry—lots of great products coming out, lots of innovation happening, and the landscape changing at godspeed in realtime is just so exciting. Software engineering and building with code has always felt like magic to me. The magical feeling is what has drawn me towards it since always, and this entire experience is just really, really magical and makes me feel so alive. The joy of building and having a tool which can help me build at the speed of thought—given I know how to instruct it properly, how to review the output properly, and understand where to be extra careful and where to let it slop it out—is just amazing. I can now utilise the time I spend travelling to and from work without guilt because all I need to do is just talk to my phone with Whisper Flow, and I know an agent is working to execute my will while I sit in a car talking to my girlfriend, listening to music, sleeping, or just simply thinking about what next I can do.

If you get to work with this technology, I seriously hope you learn to master it and develop a love of the craft because being at the centre of this is such a privilege.
